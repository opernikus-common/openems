package io.openems.edge.heater.chp.dachs;

import java.util.function.Function;

import io.openems.common.channel.AccessMode;
import io.openems.common.channel.Level;
import io.openems.common.channel.Unit;
import io.openems.common.types.OpenemsType;
import io.openems.edge.common.channel.Doc;
import io.openems.edge.common.channel.DoubleDoc;
import io.openems.edge.common.channel.EnumReadChannel;
import io.openems.edge.common.channel.IntegerDoc;
import io.openems.edge.common.channel.IntegerReadChannel;
import io.openems.edge.common.channel.StateChannel;
import io.openems.edge.common.channel.value.Value;
import io.openems.edge.common.type.TypeUtils;
import io.openems.edge.heater.api.Chp;
import io.openems.edge.heater.api.Heater;
import io.openems.edge.heater.api.ManagedChp;

public interface DachsGlt extends ManagedChp {

	public static final Function<Object, Object> SCALE_FACTOR_1 = (value) -> {
		Integer intValue = TypeUtils.getAsType(OpenemsType.INTEGER, value);
		return TypeUtils.multiply(intValue, 10);
	};

	public enum ChannelId implements io.openems.edge.common.channel.ChannelId {

		WARNING(Doc.of(Level.WARNING)), //
		ERROR(Doc.of(Level.FAULT)), //
		READ_ERROR(Doc.of(Level.FAULT).accessMode(AccessMode.READ_ONLY).text("Reading from chp failed.")), //
		WRITE_ERROR(Doc.of(Level.FAULT).accessMode(AccessMode.READ_ONLY).text("Sending commands to chp failed.")), //
		READ_RESULT_WARNING(
				Doc.of(Level.WARNING).accessMode(AccessMode.READ_ONLY).text("Some Values could not be read.")), //

		/**
		 * Hot water temperature. (Temperatur Warmwasser)
		 * <ul>
		 * <li>Type: Integer
		 * </ul>
		 */
		HOT_WATER_TEMPERATURE(
				Doc.of(OpenemsType.INTEGER).unit(Unit.DECIDEGREE_CELSIUS).accessMode(AccessMode.READ_ONLY),
				"Hka_Mw1.Temp.sbZS_Warmwasser", SCALE_FACTOR_1),

		/**
		 * Electrical work generated by the chp since the last restart.
		 * (Hka_Bd.ulArbeitElektr)
		 * <ul>
		 * <li>Type: double
		 * <li>Unit: kilowatt hours
		 * </ul>
		 */
		ELECTRICAL_WORK(new DoubleDoc().unit(Unit.KILOWATT_HOURS).accessMode(AccessMode.READ_ONLY).onInit((channel) -> {
            channel.onUpdate(newValue -> newValue.asOptional().ifPresent(dValue -> {
					var component = channel.getComponent();
					if (component instanceof Chp) {
                    ((Chp) component)._setElectricProductionEnergy(TypeUtils.getAsType(OpenemsType.INTEGER, dValue * 1000));
					}
            }));
		}),
				"Hka_Bd.ulArbeitElektr"),

		/**
		 * Thermal work generated by the chp since the last restart.
		 * (Hka_Bd.ulArbeitThermHka)
		 * <ul>
		 * <li>Type: double
		 * <li>Unit: kilowatt hours
		 * </ul>
		 */
		THERMAL_WORK(new DoubleDoc().unit(Unit.KILOWATT_HOURS).accessMode(AccessMode.READ_ONLY).onInit((channel) -> {
            channel.onUpdate(newValue -> newValue.asOptional().ifPresent(dValue -> {
					var component = channel.getComponent();
					if (component instanceof Heater) {
                    ((Heater) component)._setHeatingEnergy(TypeUtils.getAsType(OpenemsType.INTEGER, dValue * 1000));
					}
            }));
		}),
				"Hka_Bd.ulArbeitThermHka"),

		/**
		 * Thermal work generated by the condenser since the last restart.
		 * (Hka_Bd.ulArbeitThermKon)
		 * <ul>
		 * <li>Type: double
		 * <li>Unit: kilowatt hours
		 * </ul>
		 */
		THERMAL_WORK_COND(Doc.of(OpenemsType.DOUBLE).unit(Unit.KILOWATT_HOURS).accessMode(AccessMode.READ_ONLY),
				"Hka_Bd.ulArbeitThermKon"),

		/**
		 * Serial number as a string. (Hka_Bd_Stat.uchSeriennummer)
		 * <ul>
		 * <li>Type: string
		 * </ul>
		 */
		SERIAL_NUMBER(Doc.of(OpenemsType.STRING).accessMode(AccessMode.READ_ONLY), "Hka_Bd_Stat.uchSeriennummer"),

		/**
		 * Parts number as a string. (Hka_Bd_Stat.uchTeilenummer)
		 * <ul>
		 * <li>Type: string
		 * </ul>
		 */
		PARTS_NUMBER(Doc.of(OpenemsType.STRING).accessMode(AccessMode.READ_ONLY), "Hka_Bd_Stat.uchTeilenummer"),

		/**
		 * Time since last restart. (Hka_Bd.ulBetriebssekunden) (<- unit is hours, even
		 * if this says otherwise)
		 * <ul>
		 * <li>Type: double
		 * <li>Unit: hours
		 * </ul>
		 */
		RUNTIME(Doc.of(OpenemsType.DOUBLE).unit(Unit.HOUR).accessMode(AccessMode.READ_ONLY),
				"Hka_Bd.ulBetriebssekunden"),

		/**
		 * Rotations per minute of the chp engine. (Hka_Mw1.usDrehzahl)
		 * <ul>
		 * <li>Type: integer
		 * <li>Unit: rotations per minute
		 * </ul>
		 */
		RPM(Doc.of(OpenemsType.INTEGER).unit(Unit.NONE).accessMode(AccessMode.READ_ONLY), "Hka_Mw1.usDrehzahl"),

		/**
		 * Engine starts since last restart of the chp. (Hka_Bd.ulAnzahlStarts)
		 * <ul>
		 * <li>Type: integer
		 * </ul>
		 */
		ENGINE_STARTS(Doc.of(OpenemsType.INTEGER).unit(Unit.NONE).accessMode(AccessMode.READ_ONLY),
				"Hka_Bd.ulAnzahlStarts"),

		/**
		 * Requested modules setting. Only available (!=0) if Dachs has more than one
		 * module. (Anzahl der angeforderten Module, Hka_Bd.Anforderung.ModulAnzahl)
		 * <ul>
		 * <li>Type: integer
		 * </ul>
		 */
		NUMBER_OF_MODULES(Doc.of(OpenemsType.INTEGER).unit(Unit.NONE).accessMode(AccessMode.READ_ONLY),
				"Hka_Bd.Anforderung.ModulAnzahl"),

		/**
		 * Reason Run is requested (Bitcoded indicator).
		 * <ul>
		 * <li>Type: integer
		 * </ul>
		 */
		ELECTRICAL_RUN_REQUESTED(Doc.of(OpenemsType.INTEGER).unit(Unit.NONE).accessMode(AccessMode.READ_ONLY)),

		/**
		 * Bitcoded indicator for electricity released.
		 * <ul>
		 * <li>Type: integer
		 * </ul>
		 */
		ELECTRICITY_RELEASED(Doc.of(OpenemsType.INTEGER).unit(Unit.NONE).accessMode(AccessMode.READ_ONLY),
				"Hka_Bd.UStromF_Frei.bFreigabe"),

		/**
		 * Reason Run is requested (Bitcoded indicator).
		 * <ul>
		 * <li>Type: integer
		 * </ul>
		 */
		RUN_REQUESTED(Doc.of(OpenemsType.INTEGER).unit(Unit.NONE).accessMode(AccessMode.READ_ONLY),
				"Hka_Bd.UHka_Anf.usAnforderung"),

		/**
		 * Run Clearance.
		 * <ul>
		 * <li>Type: integer
		 * </ul>
		 */
		RUN_CLEARANCE(Doc.of(OpenemsType.INTEGER).unit(Unit.NONE).accessMode(AccessMode.READ_ONLY),
				"Hka_Bd.UHka_Frei.usFreigabe"),

		/**
		 * Maintenance needed flag. (Wartung_Cache.fStehtAn)
		 * <ul>
		 * <li>Type: boolean
		 * </ul>
		 */
		MAINTENANCE_FLAG(Doc.of(OpenemsType.BOOLEAN).accessMode(AccessMode.READ_ONLY), "Wartung_Cache.fStehtAn"),

		/**
		 * flag which indicates that electricity is requested.
		 * <ul>
		 * <li>Type: boolean
		 * </ul>
		 */
		ELECTRICITY_REQUESTED_FLAG(Doc.of(OpenemsType.BOOLEAN).accessMode(AccessMode.READ_ONLY),
				"Hka_Bd.UHka_Anf.Anforderung.fStrom"),

		/**
		 * Effective electric power.
		 * <ul>
		 * <li>Type: Double
		 * <li>Unit: Kilowatt
		 * </ul>
		 */
		RAW_ELECTRIC_PRODUCTION_POWER(
				new DoubleDoc().unit(Unit.KILOWATT).accessMode(AccessMode.READ_ONLY).onInit((channel) -> {
                    channel.onUpdate(newValue -> newValue.asOptional().ifPresent(dValue -> {
							var component = channel.getComponent();
							if (component instanceof Chp) {
                            ((Chp) component)._setElectricProductionPower(TypeUtils.getAsType(OpenemsType.INTEGER, dValue * 1000));
							}
                    }));
				}), "Hka_Mw1.sWirkleistung"),

		/**
		 * Flow temperature.
		 * <ul>
		 * <li>Type: Integer
		 * <li>Unit: Degree celsius 
		 * </ul>
		 */
		RAW_FLOW_TEMPERATURE(
				new IntegerDoc().unit(Unit.DECIDEGREE_CELSIUS).accessMode(AccessMode.READ_ONLY).onInit((channel) -> {
                    channel.onUpdate(newValue -> newValue.asOptional().ifPresent(iValue -> {
							var component = channel.getComponent();
							if (component instanceof Heater) {
                            ((Heater) component)._setFlowTemperature(iValue);
							}
                    }));
				}), "Hka_Mw1.Temp.sbVorlauf", SCALE_FACTOR_1),

		/**
		 * Return temperature.
		 * <ul>
		 * <li>Type: Integer
		 * <li>Unit: Degree celsius 
		 * </ul>
		 */
		RAW_RETURN_TEMPERATURE(
				new IntegerDoc().unit(Unit.DECIDEGREE_CELSIUS).accessMode(AccessMode.READ_ONLY).onInit((channel) -> {
					channel.onUpdate(newValue -> {
                        newValue.asOptional().ifPresent(iValue -> {
							var component = channel.getComponent();
							if (component instanceof Heater) {
                                ((Heater) component)._setReturnTemperature(iValue);
							}
                        });
					});
				}), "Hka_Mw1.Temp.sbRuecklauf", SCALE_FACTOR_1),

		/**
		 * Outdoor temperature. (Außentemperatur)
		 * <ul>
		 * <li>Type: Integer
		 * </ul>
		 */
		OUTDOOR_TEMPERATURE(Doc.of(OpenemsType.INTEGER).unit(Unit.DECIDEGREE_CELSIUS).accessMode(AccessMode.READ_ONLY),
				"Hka_Mw1.Temp.sbAussen", SCALE_FACTOR_1),

		/**
		 * temperature sensor 1. (Temperatur Fühler 1)
		 * <ul>
		 * <li>Type: Integer
		 * </ul>
		 */
		TEMPERATURE_SENSOR_1(Doc.of(OpenemsType.INTEGER).unit(Unit.DECIDEGREE_CELSIUS).accessMode(AccessMode.READ_ONLY),
				"Hka_Mw1.Temp.sbFuehler1", SCALE_FACTOR_1),

		/**
		 * temperature sensor 2. (Temperatur Fühler 2)
		 * <ul>
		 * <li>Type: Integer
		 * </ul>
		 */
		TEMPERATURE_SENSOR_2(Doc.of(OpenemsType.INTEGER).unit(Unit.DECIDEGREE_CELSIUS).accessMode(AccessMode.READ_ONLY),
				"Hka_Mw1.Temp.sbFuehler2", SCALE_FACTOR_1),

		STATE_WARNING(Doc.of(WarningCode.values()), "Hka_Bd.bWarnung"),
		STATE_ERROR(Doc.of(ErrorCode.values()), "Hka_Bd.bStoerung"),

		;

		private final Function<Object, Object> converter;

		private final String key;

		private final Doc doc;

		private ChannelId(Doc doc) {
			this(doc, null, (value) -> value);
		}

		private ChannelId(Doc doc, String key) {
			this(doc, key, (value) -> value);
		}

		private ChannelId(Doc doc, String key, Function<Object, Object> converter) {
			this.doc = doc;
			this.key = key;
			this.converter = converter;
		}

		public Doc doc() {
			return this.doc;
		}

		public String getKey() {
			return this.key;
		}

		/**
		 * Applies the converter belonging to the channel.
		 * 
		 * @param value the input value
		 * @return the value after applying the converter
		 */
		public Object applyConverter(Object value) {
			return this.converter.apply(value);
		}
	}

	/**
	 * Gets the Channel for {@link ChannelId#RUN_REQUESTED}.
	 * 
	 * @return the channel
	 */
	public default IntegerReadChannel getHeatRunRequestedChannel() {
		return this.channel(ChannelId.RUN_REQUESTED);
	}

	/**
     * Gets the value of the Channel for {@link ChannelId#RUN_REQUESTED}.
     *
     * @return the Channel {@link Value}
     */
	public default Value<Integer> getHeatRunRequested() {
		return this.getHeatRunRequestedChannel().value();
	}

	/**
	 * Gets the Channel for {@link ChannelId#RUN_CLEARANCE}.
	 * 
	 * @return the channel
	 */
	public default IntegerReadChannel getRunClearanceChannel() {
		return this.channel(ChannelId.RUN_CLEARANCE);
	}

	/**
     * Gets the value of the Channel for {@link ChannelId#RUN_CLEARANCE}.
     *
     * @return the Channel {@link Value}
     */
	public default Value<Integer> getRunClearance() {
		return this.getRunClearanceChannel().value();
	}

	/**
	 * Gets the Channel for {@link ChannelId#READ_RESULT_WARNING}.
	 * 
	 * @return the channel
	 */
	public default StateChannel getReadResultWarningChannel() {
		return this.channel(ChannelId.READ_RESULT_WARNING);
	}

	/**
     * Internal method to set the 'nextValue' on {@link ChannelId#READ_RESULT_WARNING}
     * Channel.
     *
     * @param value the next value
     */
	public default void _setReadResultWarning(boolean value) {
		this.getReadResultWarningChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link ChannelId#READ_ERROR}.
	 * 
	 * @return the channel
	 */
	public default StateChannel getReadErrorChannel() {
		return this.channel(ChannelId.READ_ERROR);
	}

	/**
     * Internal method to set the 'nextValue' on {@link ChannelId#READ_ERROR}
     * Channel.
     *
     * @param value the next value
     */
	public default void _setReadError(boolean value) {
		this.getReadErrorChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link ChannelId#STATE_WARNING}.
	 * 
	 * @return the channel
	 */
	public default EnumReadChannel getStateWarningChannel() {
		return this.channel(ChannelId.STATE_WARNING);
	}

	/**
     * Gets the value of the Channel for {@link ChannelId#STATE_WARNING}.
     *
     * @return the Channel {@link Value}
     */
	public default WarningCode getStateWarning() {
		return this.getStateWarningChannel().value().asEnum();
	}

	/**
     * Internal method to set the 'nextValue' on {@link ChannelId#STATE_WARNING}
     * Channel.
     *
     * @param value the next value
     */
	public default void _setStateWarning(WarningCode value) {
		this.getStateWarningChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link ChannelId#STATE_ERROR}.
	 * 
	 * @return the channel
	 */
	public default EnumReadChannel getStateErrorChannel() {
		return this.channel(ChannelId.STATE_ERROR);
	}

	/**
     * Gets the value of the Channel for {@link ChannelId#STATE_ERROR}.
     *
     * @return the Channel {@link Value}
     */
	public default ErrorCode getStateError() {
		return this.getStateErrorChannel().value().asEnum();
	}

	/**
     * Internal method to set the 'nextValue' on {@link ChannelId#STATE_ERROR}
     * Channel.
     *
     * @param value the next value
     */
	public default void _setStateError(ErrorCode value) {
		this.getStateErrorChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link ChannelId#RPM}.
	 * 
	 * @return the channel
	 */
	public default IntegerReadChannel getRpmChannel() {
		return this.channel(ChannelId.RPM);
	}

	/**
     * Gets the value of the Channel for {@link ChannelId#RPM}.
     *
     * @return the Channel {@link Value}
     */
	public default Value<Integer> getRpm() {
		return this.getRpmChannel().value();
	}

}
