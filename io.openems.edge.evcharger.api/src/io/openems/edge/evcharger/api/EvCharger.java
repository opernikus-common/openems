package io.openems.edge.evcharger.api;

import org.osgi.annotation.versioning.ProviderType;

import io.openems.common.channel.AccessMode;
import io.openems.common.channel.Level;
import io.openems.common.channel.PersistencePriority;
import io.openems.common.channel.Unit;
import io.openems.common.types.OpenemsType;
import io.openems.common.types.OptionsEnum;
import io.openems.edge.common.channel.Channel;
import io.openems.edge.common.channel.Doc;
import io.openems.edge.common.channel.EnumReadChannel;
import io.openems.edge.common.channel.IntegerReadChannel;
import io.openems.edge.common.channel.LongReadChannel;
import io.openems.edge.common.channel.StateChannel;
import io.openems.edge.common.channel.value.Value;
import io.openems.edge.common.component.OpenemsComponent;
import io.openems.edge.evcharger.api.data.ChargingType;
import io.openems.edge.evcharger.api.data.Iec62196Status;
import io.openems.edge.evcharger.api.data.PhaseRotation;
import io.openems.edge.evcharger.api.data.Status;
import io.openems.edge.meter.api.ElectricityMeter;
import io.openems.edge.meter.api.MeterType;

/**
 * EvCharger represents a read only electric vehicle charger.
 * 
 * <p>
 * An EvCharger consists of channels of type
 * <ul>
 * <li>{@link EvCharger}:ConfigChannelId
 * <li>{@link EvCharger}:RawChannelId
 * <li>{@link EvCharger}:ChannelId
 * </ul>
 * 
 * <p>
 * A new charge point hardware model needs to implement the most basic
 * functionaliy of a chargepoint only. It needs to provide only
 * <ul>
 * <li>{@link EvCharger}:ConfigChannelId
 * <li>{@link EvCharger}:RawChannelId
 * </ul>
 * 
 * <p>
 * The channelIds of {@link EvCharger}:ChannelId are automatically generated by
 * OpenEMS. See {@link GenericManagedEvChargerImpl} for more.
 * 
 * <p>
 * See also {@link EvChargerTools} for some helper tools.
 * 
 * <p>
 * Note that the EvCharger.. natures are the successor of {@link Evcs}.
 * 
 * <p>
 * <b>Additional Information:</b> Why do we use channels and not configurable
 * parameters? Channels are well defined. Bundle configuration is not defined at
 * all. It is handled by convention. This often leads to some errors when
 * implementing different chargepoint models. For example: In the past some
 * bundles have used config.minCurrent() default 6 (A) and some bundles have
 * used config.minCurrent() default 6000 (mA) in their driver implementation.
 */
@ProviderType
public interface EvCharger extends ElectricityMeter, OpenemsComponent {

	public static final int DEFAULT_MAX_CURRENT = 32_000; // mA
	public static final int DEFAULT_MIN_CURRENT = 6_000; // mA
	public static final int DEFAULT_VOLTAGE = 230; // V

	/**
	 * ConfigChannelId hold all configuration parameter of an evCharger.
	 * 
	 * <p>
	 * Set this channels once in the activate()/modified() method of the evCharger
	 * bundle.
	 */
	public enum ConfigChannelId implements io.openems.edge.common.channel.ChannelId {
		/**
		 * Charging Type.
		 *
		 * <p>
		 * Type of this EvCharger.
		 *
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: ChargingType
		 * </ul>
		 */
		CHARGING_TYPE(Doc.of(ChargingType.values()) //
				.persistencePriority(PersistencePriority.HIGH)), //

		/**
		 * Minimum current per phase this EvCharger can operate with (in mA).
		 *
		 * <p>
		 * Below this current the EvCharger must be switched of. Typical EvCharger go
		 * down to 6A then they need to be switched off.
		 * 
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OpenemsType#INTEGER}
		 * <li>Unit: {@link Unit#MILLI_AMPERE}
		 * </ul>
		 */
		MIN_CURRENT(Doc.of(OpenemsType.INTEGER) //
				.unit(Unit.MILLIAMPERE) //
				.persistencePriority(PersistencePriority.HIGH)), //

		/**
		 * Maximum current per phase this EvCharger can operate with (in mA).
		 *
		 * <p>
		 * This value should be configurable by design. This gives the installer an
		 * option to limit the chargepoint depending on cable constraints, allthough a
		 * chargepoint hardware may be able to handle higher current.
		 *
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OpenemsType#INTEGER}
		 * <li>Unit: {@link Unit#MILLI_AMPERE}
		 * </ul>
		 */
		MAX_CURRENT(Doc.of(OpenemsType.INTEGER) //
				.unit(Unit.MILLIAMPERE) //
				.persistencePriority(PersistencePriority.HIGH)),
		/**
		 * Phase Rotation.
		 * 
		 * <p>
		 * In charge parks the phases of chargepoints should be rotated when installed.
		 * This reduces phase shifting load when the majority of vehicles charge with
		 * only one or two phases. Channel provides information on the phase rotation of
		 * this chargepoint.
		 * 
		 * <p>
		 * Note: Channel is moved from EvCharger nature to ManagedEvCharger because it
		 * may be reconfigured often during installation process. The rawListeners needs
		 * to be reassigned then. If it is configured within the
		 * GenericManagedEvChargerImpl, the component can take care of it.
		 * 
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: PhaseRotation @see {@link PhaseRotation}
		 * </ul>
		 */
		PHASE_ROTATION(Doc.of(PhaseRotation.values()) //
				.accessMode(AccessMode.READ_ONLY) //
				.persistencePriority(PersistencePriority.HIGH)), //

		;

		private final Doc doc;

		private ConfigChannelId(Doc doc) {
			this.doc = doc;
		}

		@Override
		public Doc doc() {
			return this.doc;
		}
	}

	public enum RawChannelId implements io.openems.edge.common.channel.ChannelId {

		/**
		 * Total Energy of this chargepoint.
		 *
		 * <p>
		 * This should hold the value read directly from the chargepoint. Based on this
		 * value OpenEMS computes the ElectricityMeter.ActiveConsumptionEnergy. Note
		 * that it is possible to exchange the hardware with a new hardware. The new
		 * hardware starts RawActiveConsumptionEnergy at 0l, but OpenEMS takes care,
		 * that ElectricityMeter.ActiveConsumptionEnergy is a constantly increasing
		 * function to not break the UI history.
		 * 
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OpenemsType#LONG}
		 * <li>Unit: {@link Unit#WATT_HOURS}
		 * </ul>
		 */
		RAW_ACTIVE_CONSUMPTION_ENERGY(Doc.of(OpenemsType.LONG) //
				.unit(Unit.WATT_HOURS) //
				.accessMode(AccessMode.READ_ONLY) //
				.persistencePriority(PersistencePriority.HIGH)), //

		/**
		 * RawCurrentL1.
		 *
		 * <p>
		 * The raw current for phase L1. This is the value directly read from L1 of EV
		 * charger. It does not take care of phase rotation.
		 * 
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OpenemsType#INTEGER}
		 * <li>Unit: {@link Unit#MILLIAMPERE}
		 * </ul>
		 */
		RAW_CURRENT_L1(Doc.of(OpenemsType.INTEGER) //
				.unit(Unit.MILLIAMPERE) //
				.persistencePriority(PersistencePriority.HIGH)),
		/**
		 * RawCurrentL2.
		 *
		 * <p>
		 * The raw current for phase L2. This is the value directly read from L2 of EV
		 * charger. It does not take care of phase rotation.
		 * 
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OpenemsType#INTEGER}
		 * <li>Unit: {@link Unit#MILLIAMPERE}
		 * </ul>
		 */
		RAW_CURRENT_L2(Doc.of(OpenemsType.INTEGER) //
				.unit(Unit.MILLIAMPERE) //
				.persistencePriority(PersistencePriority.HIGH)),
		/**
		 * RawCurrentL3.
		 *
		 * <p>
		 * The raw current for phase L3. This is the value directly read from L3 of EV
		 * charger. Value of the chargepoint without taking into account the applied
		 * phase rotation.
		 * 
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OpenemsType#INTEGER}
		 * <li>Unit: {@link Unit#MILLIAMPERE}
		 * </ul>
		 */
		RAW_CURRENT_L3(Doc.of(OpenemsType.INTEGER) //
				.unit(Unit.MILLIAMPERE) //
				.persistencePriority(PersistencePriority.HIGH)),

		/**
		 * RawChargePower.
		 *
		 * <p>
		 * This is the chargepower delivered by the EvCharger hardware.
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OpenemsType#INTEGER}
		 * <li>Unit: {@link Unit#WATT}
		 * </ul>
		 */
		RAW_CHARGE_POWER(Doc.of(OpenemsType.INTEGER) //
				.unit(Unit.WATT) //
				.accessMode(AccessMode.READ_ONLY) //
				.persistencePriority(PersistencePriority.HIGH)), //

		/**
		 * Raw status according to IEC 62196-2, as Integer.
		 * 
		 * <p>
		 * Set to the chargepoint status according to IEC 62196. <code>
		 *   'A' -> 65
		 *   'B' -> 66
		 *   'C' -> 67
		 *   'D' -> 68
		 *   'E' -> 69
		 *   'F' -> 70
		 * </code>
		 * 
		 * <p>
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OptionsEnum}
		 * <li>Unit: {@link RawStatus}
		 * </ul>
		 */
		IEC62196_STATUS(Doc.of(Iec62196Status.values()) //
				.persistencePriority(PersistencePriority.HIGH)), //

		COMMUNICATION_FAILED(Doc.of(Level.FAULT) //
				.accessMode(AccessMode.READ_ONLY) //
				.persistencePriority(PersistencePriority.HIGH) //
				.text("Chargingstation Communication Failed " //
						+ "| Keine Verbindung zur Ladestation ")), //

		;

		private final Doc doc;

		private RawChannelId(Doc doc) {
			this.doc = doc;
		}

		@Override
		public Doc doc() {
			return this.doc;
		}

	}

	public enum ChannelId implements io.openems.edge.common.channel.ChannelId {

		/**
		 * Status according to OpenEMS.
		 * 
		 * <p>
		 * OpenEMS computes this Status based on {@link RawStatus}. Please do not set it
		 * directly within your evCharger driver bundle. Because within OpenEMS
		 * controller logic we want chargepoints which behave identically, even if they
		 * are provided by a different chargepoint hardware model.
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OptionsEnum}
		 * <li>Unit: {@link Status}
		 * </ul>
		 * 
		 */
		STATUS(Doc.of(Status.values()) //
				.persistencePriority(PersistencePriority.HIGH)), //

		/**
		 * Energy that was charged during the current or last Session.
		 *
		 * <p>
		 * This is computed by OpenEMS directly based on
		 * {@link EvCharger.RAW_CONSUMPTION_ENERGY_SESSION}.
		 * <ul>
		 * <li>Interface: EvCharger
		 * <li>Readable
		 * <li>Type: {@link OpenemsType#INTEGER}
		 * <li>Unit: {@link Unit#WATT_HOURS}
		 * </ul>
		 */
		CONSUMPTION_ENERGY_SESSION(Doc.of(OpenemsType.INTEGER) //
				.unit(Unit.WATT_HOURS) //
				.accessMode(AccessMode.READ_ONLY) //
				.persistencePriority(PersistencePriority.HIGH)), //
		;

		private final Doc doc;

		private ChannelId(Doc doc) {
			this.doc = doc;
		}

		@Override
		public Doc doc() {
			return this.doc;
		}

	}

	/**
	 * Gets the type of this Meter.
	 *
	 * @return the {@link MeterType}
	 */
	@Override
	public default MeterType getMeterType() {
		return MeterType.CONSUMPTION_METERED;
	}

	/**
	 * Gets the energy calculation object.
	 * 
	 * @return the energy calculation object.
	 */
	// public CalculateEnergyFromPower getEnergyCalculation();

	/**
	 * Gets the Channel for {@link RawChannelId#Iec62196Status}.
	 *
	 * @return the Channel
	 */
	public default Channel<Iec62196Status> getIec62196StatusChannel() {
		return this.channel(RawChannelId.IEC62196_STATUS);
	}

	/**
	 * Gets the Type of charging. See {@link RawChannelId#Iec62196Status}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Iec62196Status getIec62196Status() {
		return this.getIec62196StatusChannel().value().asEnum();
	}

	/**
	 * Internal method to set the 'nextValue' on {@link RawChannelId#Iec62196Status}
	 * Channel.
	 *
	 * @param value the next value
	 */
	public default void _setIec62196Status(Iec62196Status value) {
		this.getIec62196StatusChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link RawChannelId#CHARGING_TYPE}.
	 *
	 * @return the Channel
	 */
	public default Channel<ChargingType> getChargingTypeChannel() {
		return this.channel(ConfigChannelId.CHARGING_TYPE);
	}

	/**
	 * Gets the Type of charging. See {@link RawChannelId#CHARGING_TYPE}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default ChargingType getChargingType() {
		return this.getChargingTypeChannel().value().asEnum();
	}

	/**
	 * Internal method to set the 'nextValue' on {@link RawChannelId#CHARGING_TYPE}
	 * Channel.
	 *
	 * @param value the next value
	 */
	public default void _setChargingType(ChargingType value) {
		this.getChargingTypeChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link ConfigChannelId#PHASE_ROTATION}.
	 *
	 * @return the Channel
	 */
	public default EnumReadChannel getPhaseRotationChannel() {
		return this.channel(ConfigChannelId.PHASE_ROTATION);
	}

	/**
	 * Gets the current PhaseRotation. See {@link ConfigChannelId#PHASE_ROTATION}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default PhaseRotation getPhaseRotation() {
		return this.getPhaseRotationChannel().value().asEnum();
	}

	/**
	 * Internal method to set the 'nextValue' on
	 * {@link ConfigChannelId#PHASE_ROTATION} Channel.
	 *
	 * @param value the next value
	 */
	public default void _setPhaseRotation(PhaseRotation value) {
		this.getPhaseRotationChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link RawChannelId#RAW_CURRENT_L1}.
	 *
	 * @return the Channel
	 */
	public default IntegerReadChannel getRawCurrentL1Channel() {
		return this.channel(RawChannelId.RAW_CURRENT_L1);
	}

	/**
	 * Gets the Current. See {@link RawChannelId#RAW_CURRENT_L1}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Value<Integer> getRawCurrentL1() {
		return this.getRawCurrentL1Channel().value();
	}

	/**
	 * Internal method to set the 'nextValue' on {@link RawChannelId#RAW_CURRENT_L1}
	 * Channel.
	 *
	 * @param value the next value
	 */
	public default void _setRawCurrentL1(Integer value) {
		this.getRawCurrentL1Channel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link RawChannelId#RAW_CURRENT_L2}.
	 *
	 * @return the Channel
	 */
	public default IntegerReadChannel getRawCurrentL2Channel() {
		return this.channel(RawChannelId.RAW_CURRENT_L2);
	}

	/**
	 * Gets the Current. See {@link RawChannelId#RAW_CURRENT_L2}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Value<Integer> getRawCurrentL2() {
		return this.getRawCurrentL2Channel().value();
	}

	/**
	 * Internal method to set the 'nextValue' on {@link RawChannelId#RAW_CURRENT_L2}
	 * Channel.
	 *
	 * @param value the next value
	 */
	public default void _setRawCurrentL2(Integer value) {
		this.getRawCurrentL2Channel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link RawChannelId#RAW_CURRENT_L3}.
	 *
	 * @return the Channel
	 */
	public default IntegerReadChannel getRawCurrentL3Channel() {
		return this.channel(RawChannelId.RAW_CURRENT_L3);
	}

	/**
	 * Gets the Current. See {@link RawChannelId#RAW_CURRENT_L3}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Value<Integer> getRawCurrentL3() {
		return this.getRawCurrentL3Channel().value();
	}

	/**
	 * Internal method to set the 'nextValue' on {@link RawChannelId#RAW_CURRENT_L3}
	 * Channel.
	 *
	 * @param value the next value
	 */
	public default void _setRawCurrentL3(Integer value) {
		this.getRawCurrentL3Channel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link RawChannelId#RAW_CHARGE_POWER}.
	 *
	 * @return the Channel
	 */
	public default IntegerReadChannel getRawChargePowerChannel() {
		return this.channel(RawChannelId.RAW_CHARGE_POWER);
	}

	/**
	 * Gets the RawCharge Power in [W]. See {@link RawChannelId#RAW_CHARGE_POWER}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Value<Integer> getRawChargePower() {
		return this.getRawChargePowerChannel().value();
	}

	/**
	 * Internal method to set the 'nextValue' on
	 * {@link RawChannelId#RAW_CHARGE_POWER} Channel.
	 *
	 * @param value the next value
	 */
	public default void _setRawChargePower(Integer value) {
		this.getRawChargePowerChannel().setNextValue(value);
	}

	/**
	 * Internal method to set the 'nextValue' on
	 * {@link RawChannelId#RAW_CHARGE_POWER} Channel.
	 *
	 * @param value the next value
	 */
	public default void _setRawChargePower(int value) {
		this.getRawChargePowerChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link RawChannelId#RAW_ACTIVE_CONSUMPTION_ENERGY}.
	 *
	 * @return the Channel
	 */
	public default LongReadChannel getRawActiveConsumptionEnergyChannel() {
		return this.channel(RawChannelId.RAW_ACTIVE_CONSUMPTION_ENERGY);
	}

	/**
	 * Gets the Active Consumption Energy in [Wh_Σ]. This relates to negative
	 * ACTIVE_POWER. See {@link RawChannelId#RAW_ACTIVE_CONSUMPTION_ENERGY}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Value<Long> getRawConsumptionEnergySession() {
		return this.getRawActiveConsumptionEnergyChannel().value();
	}

	/**
	 * Internal method to set the 'nextValue' on
	 * {@link RawChannelId#RAW_ACTIVE_CONSUMPTION_ENERGY} Channel.
	 *
	 * @param value the next value
	 */
	public default void _setRawConsumptionEnergySession(Long value) {
		this.getRawActiveConsumptionEnergyChannel().setNextValue(value);
	}

	/**
	 * Internal method to set the 'nextValue' on
	 * {@link RawChannelId#RAW_CONSUMPTION_ENERGY_SESSION} Channel.
	 *
	 * @param value the next value
	 */
	public default void _setRawConsumptionEnergySession(long value) {
		this.getRawActiveConsumptionEnergyChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link ConfigChannelId#MAX_CURRENT}.
	 *
	 * @return the Channel
	 */
	public default IntegerReadChannel getMaxCurrentChannel() {
		return this.channel(ConfigChannelId.MAX_CURRENT);
	}

	/**
	 * Gets the Max Current of this hardware in [mA]. See
	 * {@link ConfigChannelId#MAX_CURRENT}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Value<Integer> getMaxCurrent() {
		return this.getMaxCurrentChannel().value();
	}

	/**
	 * Internal method to set the 'nextValue' on {@link ConfigChannelId#MAX_CURRENT}
	 * Channel.
	 *
	 * @param value the next value
	 */
	public default void _setMaxCurrent(Integer value) {
		this.getMaxCurrentChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link ConfigChannelId#MIN_CURRENT}.
	 *
	 * @return the Channel
	 */
	public default IntegerReadChannel getMinCurrentChannel() {
		return this.channel(ConfigChannelId.MIN_CURRENT);
	}

	/**
	 * Gets the Min Current of this hardware in [mA]. See
	 * {@link ConfigChannelId#MIN_CURRENT}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Value<Integer> getMinCurrent() {
		return this.getMinCurrentChannel().value();
	}

	/**
	 * Internal method to set the 'nextValue' on {@link ConfigChannelId#MIN_CURRENT}
	 * Channel.
	 *
	 * @param value the next value
	 */
	public default void _setMinCurrent(Integer value) {
		this.getMinCurrentChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for
	 * {@link RawChannelId#CHARGINGSTATION_COMMUNICATION_FAILED}.
	 *
	 * @return the Channel
	 */
	public default StateChannel getChargingstationCommunicationFailedChannel() {
		return this.channel(RawChannelId.COMMUNICATION_FAILED);
	}

	/**
	 * Gets the Failed state channel for a failed communication to the EVCS. See
	 * {@link RawChannelId#CHARGINGSTATION_COMMUNICATION_FAILED}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Value<Boolean> getChargingstationCommunicationFailed() {
		return this.getChargingstationCommunicationFailedChannel().value();
	}

	/**
	 * Internal method to set the 'nextValue' on
	 * {@link RawChannelId#CHARGINGSTATION_COMMUNICATION_FAILED} Channel.
	 *
	 * @param value the next value
	 */
	public default void _setChargingstationCommunicationFailed(boolean value) {
		this.getChargingstationCommunicationFailedChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link RawChannelId#Status}.
	 *
	 * @return the Channel
	 */
	public default Channel<Status> getStatusChannel() {
		return this.channel(ChannelId.STATUS);
	}

	/**
	 * Gets the Type of charging. See {@link RawChannelId#Status}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Status getStatus() {
		return this.getStatusChannel().value().asEnum();
	}

	/**
	 * Internal method to set the 'nextValue' on {@link RawChannelId#Status}
	 * Channel.
	 *
	 * @param value the next value
	 */
	public default void _setStatus(Status value) {
		this.getStatusChannel().setNextValue(value);
	}

	/**
	 * Gets the Channel for {@link RawChannelId#CONSUMPTION_ENERGY_SESSION}.
	 *
	 * @return the Channel
	 */
	public default IntegerReadChannel getConsumptionEnergySessionChannel() {
		return this.channel(ChannelId.CONSUMPTION_ENERGY_SESSION);
	}

	/**
	 * Gets the Consumption Energy in [Wh_Σ]. This relates to negative ACTIVE_POWER.
	 * See {@link RawChannelId#CONSUMPTION_ENERGY_SESSION}.
	 *
	 * @return the Channel {@link Value}
	 */
	public default Value<Integer> getConsumptionEnergySession() {
		return this.getConsumptionEnergySessionChannel().value();
	}

	/**
	 * Internal method to set the 'nextValue' on
	 * {@link RawChannelId#CONSUMPTION_ENERGY_SESSION} Channel.
	 *
	 * @param value the next value
	 */
	public default void _setConsumptionEnergySession(Integer value) {
		this.getConsumptionEnergySessionChannel().setNextValue(value);
	}

	/**
	 * Internal method to set the 'nextValue' on
	 * {@link RawChannelId#CONSUMPTION_ENERGY_SESSION} Channel.
	 *
	 * @param value the next value
	 */
	public default void _setConsumptionEnergySession(int value) {
		this.getConsumptionEnergySessionChannel().setNextValue(value);
	}
}
